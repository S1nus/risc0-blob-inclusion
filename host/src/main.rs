use celestia_types::nmt::NamespacedHashExt;
use celestia_types::{nmt::Namespace, Blob, Commitment, ExtendedHeader};
use nmt_rs::row_inclusion;
use std::fs::File;
use std::io::prelude::*;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.

use methods::{
    BLOBRZ_ELF, BLOBRZ_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let my_namespace = Namespace::new_v0(&[1, 2, 3, 4, 5]).expect("Invalid namespace");

    let header_bytes = std::fs::read("header.dat").unwrap();
    let dah = ExtendedHeader::decode_and_validate(&header_bytes).unwrap();
    let row_roots = &dah.dah.row_roots;
    let col_roots = &dah.dah.column_roots;
    let row_and_col_leaves: Vec<_> = dah
        .dah
        .row_roots
        .iter()
        .chain(dah.dah.column_roots.iter())
        .map(|root| root.to_array())
        .collect();
    let (computed_root_hash, row_inclusion_proofs) = row_inclusion::proofs_from_byte_slices(
        &row_and_col_leaves
            .iter()
            .map(|leaf| leaf.as_ref())
            .collect::<Vec<_>>()[..],
    );
    println!("just for fun, let's verify them all.");
    for proof in row_inclusion_proofs.iter() {
        println!(
            "proof valid: {}",
            proof.verify(dah.dah.hash().as_bytes().try_into().unwrap())
        );
    }

    let blob_bytes = std::fs::read("blob.dat").unwrap();
    let mut blob = Blob::new(my_namespace, blob_bytes).unwrap();
    // hardcoded because whoops
    blob.index = 8;

    let blob_size: u32 = (blob.data.len() / 512).try_into().unwrap(); // num shares
    println!("blob size: {}", blob_size);
    let square_size: u32 = row_roots.len().try_into().unwrap();
    println!("Square size: {}", square_size);
    let blob_index: u32 = blob.index.try_into().unwrap();
    let first_row_index = blob_index / square_size;
    println!("First row index: {}", first_row_index);
    let last_row_index = first_row_index + (blob_size / square_size);
    println!("last row index: {}", last_row_index);

    let proofs_file = File::open("proofs.json").unwrap();
    let proofs: Vec<celestia_types::nmt::NamespaceProof> =
        serde_json::from_reader(proofs_file).unwrap();

    let shares = blob.to_shares().expect("Failed to split blob to shares");
    let leaf_hashes: Vec<_> = shares.iter().map(|share| share.as_ref()).collect();

    /*let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();*/

    let mut env = ExecutorEnv::builder();

    env.write(&false);

    env.write_slice(&dah.dah.hash().as_bytes());
    env.write(&(last_row_index as u32 - first_row_index as u32));
    env.write(&my_namespace);

    println!("len leaf_hashes: {}", leaf_hashes.len());
    println!("size of leaf_hash: {}", leaf_hashes[0].len());
    for hash in leaf_hashes.iter() {
        env.write_slice(hash);
    }

    println!("{}", last_row_index - first_row_index);
    for i in first_row_index..last_row_index {
        println!("i: {}", i);
        env.write(&row_roots[i as usize]);
        env.write(&row_inclusion_proofs[i as usize]);
        env.write(&proofs[i as usize]);
    }

    let built_env = env.build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover
        .prove(built_env, BLOBRZ_ELF)
        .unwrap();

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    // TODO: figure out how to do this
    // let _output: u32 = receipt.journal.decode().unwrap();
    let output: bool = receipt.journal.decode().unwrap();
    println!("result: {}", output);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(BLOBRZ_ID)
        .unwrap();
}
